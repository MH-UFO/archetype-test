I need you to generate React code for a personality archetype test results component. The project is a React app (using functional components and hooks). There is a main component called Test.jsx that handles a quiz with 70 questions (10 per category). Each question has 5 options scored from 1 to 5 (Likert scale: 1=Strongly Disagree, 5=Strongly Agree). After the user answers all questions, Test.jsx collects the answers in a hook called "answers", which is an array of objects in this format: [{ id: number (question ID), answer: number (1-5 score), answer_category: string (one of: 'dominance', 'strategy', 'creativity', 'independence', 'emotion', 'cunning', 'depth') }]. There is nothing about the chart's logic in Test.jsx itself—after answering, it just prepares this "answers" array.

Now, create a separate component named chart.jsx that:
- Imports necessary libraries (e.g., React, and Chart.js for the chart—do NOT use Recharts; instead, use Chart.js to create a new, beautiful bar chart).
- Receives the "answers" array as a prop from Test.jsx (e.g., via a hook or state passed down).
- Computes and displays the results in a chart after the test is finished.
- Is rendered conditionally in Test.jsx only after the test is complete (e.g., if answers.length === 70, show <Chart answers={answers} />).

Explain and implement the chart's logic as follows (this is the core computation—make it clear in comments in the code):
1. Group the answers by category: There are 7 categories ('dominance', 'strategy', 'creativity', 'independence', 'emotion', 'cunning', 'depth'), each with exactly 10 questions. Calculate the average score for each category: sum of answers in that category divided by 10 (result: 1-5 scale).
2. Use these predefined weight profiles for 8 archetypes (4 male, 4 female). Store them as objects or arrays in the code. Transliterate archetype names to Persian (e.g., 'Zeus' as 'زئوس', 'Apollo' as 'آپولو', etc.):
   Masculine (Male):
   - زئوس: [20, 16, 10, 16, 6, 12, 10] (for dominance, strategy, creativity, independence, emotion, cunning, depth)
   - آپولو: [6, 18, 16, 12, 9, 6, 16]
   - آرس: [19, 8, 6, 16, 16, 6, 6]
   - هرمس: [6, 14, 18, 16, 6, 20, 10]
   Feminine (Female):
   - آتنا: [10, 20, 12, 12, 6, 14, 16]
   - آفرودیت: [6, 8, 18, 9, 20, 12, 12]
   - آرتمیس: [10, 12, 10, 20, 6, 12, 16]
   - پرسفون: [4, 10, 12, 6, 16, 6, 20]
3. Create a user vector: An array of the 7 average category scores (e.g., [4.2, 3.5, 2.8, 4.0, 2.1, 3.7, 3.0]).
4. For each archetype, calculate cosine similarity between the user vector and the archetype's weight vector. Formula: (dot product of user and archetype) / (magnitude of user * magnitude of archetype). This gives a similarity score between -1 and 1 (higher = better match). Use this to rank all 8 archetypes (not gender-locked).
5. Determine top 1-2 archetypes: The ones with the highest similarity scores.
6. Display a new bar chart (using Chart.js) showing the user's 7 category averages (bars from 1-5). Translate category names to Persian for display (e.g., 'dominance' as 'تسلط', 'strategy' as 'استراتژی', 'creativity' as 'خلاقیت', 'independence' as 'استقلال', 'emotion' as 'احساسات', 'cunning' as 'زیرکی', 'depth' as 'عمق').
7. Add a "clarity index": (top score - second score) / max possible (if low, say "You have a blended type" in Persian: "شما نوع ترکیبی دارید").

All displayed results and text must be in Persian (Farsi). For example:
- "Your top match: Zeus (70% similarity)" should be "بهترین تطابق شما: زئوس (۷۰% شباهت)".
- Chart title: "نمودار امتیازات دسته‌بندی‌های شما".
- Use Persian for all labels, descriptions, and outputs.

Fix the chart to make it beautiful and exactly match the project's overall style: Modern and clean, with a white background, primary color gradient from #007BFF (blue) to #00BFFF (light blue) for bars to add visual appeal, secondary #6C757D (gray) for text, sans-serif font (e.g., 'Vazir' or 'Tahoma' for Persian support), softer rounded corners (e.g., border-radius: 16px), subtle shadows, smooth animations (e.g., fade-in on load and hover effects with scale), and additional aesthetic elements like custom tooltips with icons, grid lines in soft gray, and beautiful bar styling (e.g., with borders and fills). Make the chart a bit wider (e.g., minimum width 1000px, height 500px, with extra padding for a spacious, elegant look). Use Tailwind CSS classes like 'bg-white p-8 rounded-2xl shadow-xl max-w-5xl mx-auto transition-all duration-300 hover:shadow-2xl' if Tailwind is used—assume Tailwind is available and match it to the project's style (e.g., if the project uses blue themes, emphasize that). If not using Tailwind, use inline CSS. Ensure it's mobile-friendly but appears more prominent, beautiful, and polished on desktop with the enhanced styles. Remove any previous chart library (like Recharts) and create a new one with Chart.js for better customization and beauty.

In Test.jsx, show a snippet of how to integrate: Use a state like const [answers, setAnswers] = useState([]); ... and conditionally render <Chart answers={answers} /> after test completion.

Output the full code for chart.jsx and a snippet for Test.jsx integration. Include comments explaining the logic in English for clarity, but all UI text in Persian.